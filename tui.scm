(include "tui/input.scm")

(define (waddstr* win str)
  (handle-exceptions exn #t
    (waddstr win str)))

(define (refresh-statuswin)
  (let* ((regular-notifs (lset-difference eq? *notifications* *highlights*))
         (highlights-names (map room-display-name *highlights*))
         (notifs-names (map room-display-name regular-notifs)))
    (werase statuswin)
    (waddstr* statuswin (sprintf "Room: ~a | " (room-display-name (current-room))))
    (wcolor_set statuswin 2 #f) ;; highlight foreground
    (waddstr* statuswin (sprintf "~a" (string-join highlights-names " " 'suffix)))
    (wcolor_set statuswin 1 #f) ;; regular foreground
    (waddstr* statuswin (sprintf "~a" (string-join notifs-names " ")))))

(define *requested-holes* '())

(define (refresh-messageswin)
  (let ((timeline (room-timeline (current-room) limit: rows))
        (read-marker (read-marker-ref (current-room))))
    (werase messageswin)
    (for-each
      (lambda (evt+ctx)
        ;; Visible holes are dynamically loaded
        (when (equal? (mref '(type) (car evt+ctx))
                      "com.upyum.ensemble.hole")
          (let* ((from (mref '(content from) (car evt+ctx)))
                 (hole (list (current-room) from))
                 (limit rows))
            (info "[hole-detected] ~a ~s ~a~%" (current-room) hole limit)
            (when (and (not (member hole *requested-holes*))
                       (not (zero? limit)))
              (set! *requested-holes* (cons hole *requested-holes*))
              (defer 'hole-messages request-hole-messages
                     (current-room) (car evt+ctx) (caddr evt+ctx)
                     limit hole))))
        (maybe-newline)
        (wprintw messageswin "~A" (print-event (car evt+ctx) (cadr evt+ctx)))
        (when (and read-marker (equal? read-marker (mref '(event_id) (car evt+ctx))))
          (maybe-newline)
          (wprintw messageswin "~A" (make-string cols #\-))))
      (reverse timeline))))

(define (maybe-newline)
  (let-values (((l c) (getyx messageswin)))
    (unless (zero? c) (wprintw messageswin "~%"))))

(define (room-display-name id)
  (let ((ctx (room-context id)))
    (or (room-name ctx)
        (json-true? (mref '(("" . m.room.canonical_alias) alias) ctx))
        (and-let* ((v (json-true? (mref '(("" . m.room.aliases) aliases) ctx))))
             (vector-ref v 0))
        (and-let* ((members (room-members ctx))
                   (check (= (length members) 2))
                   (others (remove (lambda (p) (equal? (caar p) (string-downcase (mxid)))) members)))
             (or (member-displayname (caaar others) ctx)
                 (caaar others)))
        (symbol->string id))))

(define (switch-room room-id)
  (let ((room (room-exists? room-id)))
    (if room
        (begin
          (current-room room-id)
          (set! *notifications* (delete! room-id *notifications* eq?))
          (set! *highlights* (delete! room-id *highlights* eq?))
          (refresh-statuswin)
          (refresh-messageswin)
          )
        #f)))

(define (find-room regex)
  (define (searched-string ctx)
    (or (room-name ctx)
        (json-true? (mref '(("" . m.room.canonical_alias) alias) ctx))
        (and-let* ((v (json-true? (mref '(("" . m.room.aliases) aliases) ctx))))
             (vector-ref v 0))
        (string-join
         (filter-map (lambda (p)
                       (and (equal? (cdar p) 'm.room.member)
                            (or (member-displayname (caar p) ctx)
                                (caar p))))
                     ctx))
        ""))
  (find (lambda (room-id)
          (irregex-search (irregex regex 'i)
                          (searched-string (room-context room-id))))
        (joined-rooms)))

(define (mark-last-message-as-read)
  (let* ((last-evt (caar (room-timeline (current-room) limit: 1)))
         (id (mref '(event_id) last-evt)))
    (when id
      (room-mark-read (current-room) id))))

(define (request-hole-messages room-id hole-evt hole-id limit hole)
  (let* ((msgs (room-messages room-id from: (mref '(content from) hole-evt) limit: limit dir: 'b)))
    (list room-id hole-id msgs hole)))

(define (fill-hole room-id hole-id msgs hole)
  (let* ((incoming-events (mref '(chunk) msgs))
         (new-events (reverse! (filter-out-known-events! (vector->list incoming-events))))
         (number (+ (length new-events) 2))
         (neighs (event-neighbors room-id hole-id))
         (incr (if (car neighs) (/ (- (caddr neighs) (car neighs)) number) 1))
         (start (if (car neighs) (+ (car neighs) incr) (- (caddr neighs) number)))
         (ctx-id "empty-state")
         )
    (info "[fill-hole] ~a ~a ~s number: ~a start: ~a incr: ~a end: ~a~%"
          room-id hole-id neighs number start incr (+ start -1 (* number incr)))
    (with-transaction db
      (lambda ()
        ;; New hole
        (unless (null? new-events)
          (let ((evt-id (sprintf "hole-~A-~A" room-id start)))
            (event-set! evt-id
                        `((type . "com.upyum.ensemble.hole")
                          (content (from . ,(mref '(end) msgs))))
                        ctx-id)
            (info "[new-hole] room: ~A seq: ~A evt: ~A~%" room-id start evt-id)
            (branch-insert! room-id start evt-id)
            (set! start (+ start incr))))
        (branch-remove! hole-id)
        (for-each
          (lambda (i evt)
            (let ((evt-id (mref '(event_id) evt)))
              (event-set! evt-id evt ctx-id)
              (branch-insert! room-id
                              (+ start (* i incr))
                              evt-id)))
          (iota (length new-events))
          new-events)))
    (set! *requested-holes* (delete! hole *requested-holes*))
    (refresh-messageswin)))

(define (filter-out-known-events! evts)
  (take-while! (lambda (evt) (null? (event-ref (mref '(event_id) evt))))
               evts))

(define (initialize-room! room-data)
  (let* ((room-id (car room-data))
         (events (mref '(state events) (cdr room-data)))
         (state (initial-context events))
         (state-id (if (null? state)
                       "empty-state"
                       (mref '(event_id)
                             (vector-ref events (sub1 (vector-length events)))))))
    (state-set! state-id state)
    (last-state-set! room-id state-id)
    (list state-id state)))

(define (startup)
  (set! (signal-handler signal/winch)
    (lambda (_) (defer 'resize (lambda () #t))))
  (set! (signal-handler signal/int)
    (lambda (_) (reset)))
  (start-interface)
  (let* ((first-batch (sync since: (config-ref 'next-batch)))
         (next (handle-sync first-batch #f)))
    (switch-room (any-room))
    (defer 'sync sync timeout: 30000 since: next)
    (defer 'input get-input)
    (refresh-statuswin)
    (main-loop)))

(define (main-loop)
  (wnoutrefresh messageswin)
  (wnoutrefresh statuswin)
  (wnoutrefresh inputwin)
  (doupdate)
  (let ((th (gochan-recv ui-chan)))
    (receive (who datum) (thread-join-protected! th)
      (case who
        ((sync) (defer 'sync sync timeout: 30000 since: (handle-sync datum)))
        ((input) (handle-input datum) (defer 'input get-input))
        ((resize) (resize-terminal))
        ((hole-messages) (apply fill-hole datum))
        (else  (info "Unknown defered procedure: ~a ~s~%" who datum))
         ))
      )
  (main-loop))

(define (thread-join-protected! thread)
  (receive data (handle-exceptions exn exn (thread-join! thread))
    (if (uncaught-exception? (car data))
        (condition-case (signal (uncaught-exception-reason (car data)))
          (exn (exn i/o net)  (retry exn) (values 'no-one #f))
          (exn (exn http server-error)  (retry exn) (values 'no-one #f)))
        (apply values data))))

(define (handle-sync batch #!optional (update-ui #t))
  (let ((next (mref '(next_batch) batch)))
    #;(info "[~A] update: ~a~%" (seconds->string) next)
    (with-transaction db
      (lambda ()
        (for-each (cut advance-room <> update-ui) (mref '(rooms join) batch))
        (config-set! 'next-batch next)))
    next))

(define (get-input)
  (thread-wait-for-i/o! tty-fileno #:input)
  (wget_wch inputwin))

(define (advance-room room-data #!optional (update-ui #t))
  (let* ((room-id (car room-data))
         (window-dirty #f)
         (limited (mref '(timeline limited) (cdr room-data)))
         (events (mref '(timeline events) (cdr room-data)))
         (ephemerals (mref '(ephemeral events) (cdr room-data)))
         (state (mref '(state events) (cdr room-data)))
         (notifs (mref '(unread_notifications notification_count) (cdr room-data)))
         (highlights (mref '(unread_notifications highlight_count) (cdr room-data)))
         (base-sequence (add1 (branch-last-sequence-number room-id)))
         (init-ctx (cond ((and (room-exists? room-id) (vector? state) (not (vector-empty? state)))
                          (let ((id (mref '(event_id)
                                          (vector-ref state (sub1 (vector-length state)))))
                                (ctx (vector-fold (lambda (i ctx evt) (update-context ctx evt))
                                                  (room-context room-id)
                                                  state)))
                            (state-set! id ctx)
                            (list id ctx)))
                         ((room-exists? room-id)
                          (room-last-state-id-and-state room-id))
                         (else
                           (initialize-room! room-data)))))
    ;; Timeline Hole
    (when limited
      (info "======= LIMITED~%")
      (let ((evt-id (sprintf "hole-~A-~A" room-id base-sequence)))
        (event-set! evt-id
                    `((type . "com.upyum.ensemble.hole")
                      (content (from . ,(mref '(timeline prev_batch) (cdr room-data)))))
                    (car init-ctx))
        (info "room: ~A seq: ~A evt: ~A~%" room-id base-sequence evt-id)
        (branch-insert! room-id base-sequence evt-id)
        (set! base-sequence (add1 base-sequence))))
    ;; Timeline
    (vector-for-each (lambda (i evt)
                       (let* ((id+old-ctx init-ctx)
                              (prev-ctx-id (car id+old-ctx))
                              (old-ctx (cadr id+old-ctx))
                              (new-ctx (update-context old-ctx evt))
                              (evt-id (mref '(event_id) evt)))
                         (event-set! evt-id evt prev-ctx-id)
                         (when (not (eq? old-ctx new-ctx))
                           (state-set! evt-id new-ctx)
                           (set! init-ctx (list evt-id new-ctx)))
                         (last-state-set! room-id (car init-ctx))
                         (branch-insert! room-id
                                         (+ base-sequence i)
                                         evt-id)
                         (set! window-dirty #t)
                         ))
                     events)
    ;; Ephemerals
    (vector-for-each (lambda (i evt)
                       (when (equal? (mref '(type) evt) "m.receipt")
                         (let ((datum (mref '(content) evt)))
                           (for-each (lambda (id+reads)
                                       (when (member (string-downcase (mxid))
                                                     (map (o string-downcase symbol->string car)
                                                       (mref '(m.read) (cdr id+reads))))
                                         (info "[marker] id+reads: ~s~%" id+reads)
                                         (read-marker-set! room-id (car id+reads))
                                         (set! window-dirty #t)))
                             datum)
                           )))
                     ephemerals)
    (when (and update-ui window-dirty (eq? (current-room) room-id))
      (refresh-messageswin))
    (when (and highlights (> highlights 0) (not (eq? (current-room) room-id)))
      (set! *highlights* (lset-adjoin eq? *highlights* room-id))
      (when update-ui (refresh-statuswin) (beep)))
    (when (and notifs (> notifs 0) (not (eq? (current-room) room-id)))
      (set! *notifications* (lset-adjoin eq? *notifications* room-id))
      (when update-ui (refresh-statuswin)))
  ))

(define (resize-terminal)
  (let ((rows+cols (ioctl-winsize tty-fileno)))
    (set! rows (car rows+cols))
    (set! cols (cadr rows+cols))
    (resizeterm rows cols)
    (wresize messageswin (- rows 2) cols)
    (mvwin messageswin 0 0)
    (wresize statuswin 1 cols)
    (mvwin statuswin (- rows 2) 0)
    (wresize inputwin 1 cols)
    (mvwin inputwin (- rows 1) 0)
    (refresh-messageswin)
    (refresh-statuswin)
    (refresh-inputwin)))
